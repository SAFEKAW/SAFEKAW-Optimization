---
title: "Common input file"
author: "BRW"
date: "2025-08-15"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Common inputs for SAFEKAW submodels
- Goal of this file is to get input variables for submodels (components) all into consistent spatial scale (basin) and units

- focus models so far are 1) Crop model and 2) SW quality model
- These both require (for now) inputs from:
    - Climate (precip.; mm)
        - crop is total ppt each year (summed)
        - SW model is basin average per year
        
    - Land use (ha)
        - SW quality has all land use, with cultivated lumped
        - crop only has corn, soybean, wheat and sorghum
        
    - Irrigation (mm for crop; m3 for SW quality)
    
```{r}
#workspace
source(file.path("code", "paths+packages.R"))
```
    
  
## Climate
 - Two submodels have different climate data sources
 - Crop model is annual and for each county, while water quality is monthly averages over entire basin 
 - Using county data, but cannot calculate SPEI in SW quality model if I do this (I can, it'll just be more pieces to move and optimize...)

```{r}
yrs_common <- 1990:2023

# County-level climate data
df_climate_county <- read_csv(file.path("data", "ClimateData_County.csv")) |>
  filter(Year %in% yrs_common)|>
  mutate(
    FIPS = as.character(FIPS),
    spatial_scale = "county", 
    source = "Crop input" ,
  ) |>
  group_by(Year, FIPS, spatial_scale) |>
  summarize(
    precip_mm = sum(precip_mm_gridmet),
    precip_mm_avg = mean(precip_mm_gridmet),
    tmin_C_avg = mean(tmmn_C_gridmet),
    tmax_C_avg = mean(tmmx_C_gridmet),
    .groups = "drop"
  )



```
 - need to check that the counties are clipped to watershed boundary!!! 

## Land use
  - Similar to above
```{r}
#crop
df_landcover <- read_csv(file.path("data", "LandCoverData-CDL_County.csv"))

df_landcover_county <- 
 df_landcover |> 
  group_by(FIPS, , Year, LandCover) |>
  summarize(area_ha_mean = mean(area_ha, na.rm = TRUE),
            area_prc_mean = mean(area_prc, na.rm = TRUE))  |>
  mutate(
    FIPS = as.character(FIPS),
    spatial_scale = "county",
    source = "Crop input" ) |> 
  dplyr::select(Year, FIPS, spatial_scale, LandCover, area_ha_mean, area_prc_mean)



landCoverGroups <- data.frame(
  LandCover = c("Developed",
                "Grass/Pasture/Shrubland",
                "Corn", "Double Crop", "Other Crops", "Sorghum", "Soybeans", "Wheat"),
  LandCoverGroup = c("developed", "grassPastureHay", rep("all cult", 6)))

df_landcover_all_class <- 
  df_landcover_county|> 
  left_join(landCoverGroups, by = "LandCover") |> na.omit() |>
  mutate(Crop = 
           case_when(
             LandCover == "Corn" ~ "Corn", 
             LandCover == "Sorghum" ~ "Sorghum",
             LandCover == "Soybeans" ~ "Soybeans", # rough average of irr and rainfed
             LandCover == "Wheat" ~ "Wheat",
             TRUE ~ NA) )



```
   - likely need to add in the NLCD early years (1990~2005) from Shreya's model and do a linear regression to gap fill!?
   - Crop model needs to subset within model wrapper
   
   
## Irrigated water use
  - three potential data sources: WaterUseData_County.csv (crop model), WaterUseData_EKSRB.csv (sw qualtiy model), 
  intermediate between the two (WaterUseByCrop_EKSRB.csv)
  - using county data, leaving irr as mm for both crop and SW quality models
```{r}
#crop
df_irrigation_in <- read_csv(file.path("data", "WaterUseData_County.csv")) |> 
  subset(Year %in% yrs_common) |> 
  mutate(irrigation_WaterUse_mm = irrigation_mm_mean , 
       #  irrigation_WaterUse_ha = ,
         FIPS = as.character(FIPS),
         spatial_scale = "county",
         source = "Crop input",
         LandCoverGroup = "all cult") |> #normalied to crop area only, not entire county
  dplyr::select(Year, FIPS, spatial_scale, Crop, LandCoverGroup, irrigation_WaterUse_mm, n_pdiv)

df_irrigation_CropSum <- df_irrigation_in |> group_by(Year) |>
  summarise(irrigation_WaterUse_mm = mean(irrigation_WaterUse_mm)) |> #should this be summed or averaged>????
  mutate(spatial_scale = "basin")


```

## Fertilizer 
  - right now just using constant, look up avg'd of rainfed and irr
  - Need by county and over time by crop (TREND + excel file?)?? 
  - This ^^ could be a later thing, we would have to make assumptions for future scenarios though... 
```{r}
 
df_landCoverFertilizer_county <-
  df_landcover |> 
  filter(LandCover %in% c("Corn", "Sorghum","Soybeans", "Wheat")) |>
  mutate(fertilizer_kgHa = 
           case_when(
             LandCover == "Corn" ~ 250, # rough average of irr and rainfed
             LandCover == "Sorghum" ~ 112,
             LandCover == "Soybeans" ~ 56, # rough average of irr and rainfed
             LandCover == "Wheat" ~ 89,
             TRUE ~ NA_real_),
        fertilizer_kgCrop = fertilizer_kgHa * area_ha,
        spatial_scale = "county", 
        FIPS = as.character(FIPS),
        source = "csv") |>
        rename(Crop = LandCover)  |>
  dplyr::select(Year, FIPS, spatial_scale, Crop, fertilizer_kgCrop)


```



## Joining all input datasets
```{r}
df_combined <- 
  df_landcover_all_class |> #need to get historical land use?!
  left_join(df_irrigation_in , c("Year", "FIPS", "spatial_scale", "LandCoverGroup", "Crop")) |> 
  left_join(df_landCoverFertilizer_county,  c("Year", "FIPS", "spatial_scale", "Crop")) |>
  left_join(df_climate_county, c("Year", "FIPS", "spatial_scale"))

unique(df_combined$Year)
```


  - in terms of integration, irr needs to be a fx of land use area, which means I need irr as vol!!

## model wrappers
  1. Crop model
    - additional inputs = crop yield
    - select only corn, soy, sorghum, wheat (!is.na(Crop))
    - model wrapper
    
    - Things to consider:
      - with this approach only have data from 2006-2023 bc of land use data..
      
```{r}
#adding additional inputs and trimming
df_yield <- read_csv(file.path("data", "CropYieldData_County.csv")) |> 
  subset(Year %in% yrs_common) |> mutate(FIPS = as.character(FIPS))


df_crop <- df_combined |> filter(!is.na(Crop)) |>
  left_join(df_yield, by = c("Year", "FIPS", "Crop")) |> 
  mutate(irrigation_WaterUse_mm = ifelse(WaterManagement == "Non-Irrigated", 0, irrigation_WaterUse_mm)) |> 
  # calculate water available
  mutate(totalWater_mm = precip_mm + irrigation_WaterUse_mm) 

area_ha_thres <- 64.75*10 # 160 acre quarter-section is 64.75 ha
pdiv_thres <- 3
df_crop <- 
  df_crop |> 
  filter(!(WaterManagement == "Irrigated" & n_pdiv < pdiv_thres)) |> 
  filter(area_ha_mean > area_ha_thres) 

#Model wrapper to fit yield models by crop
fit_yield_models <- function(data, crop) {
  
  df_crop <- subset(data, Crop == crop)
  
  # decide predictors based on crop
  if (crop == "Sorghum") {
    formula_kcal <- yield_kcalHa_detrended ~ poly(totalWater_mm, 2) + tmin_C_avg + tmax_C_avg
    formula_kg   <- yield_kgHa_detrended ~ poly(totalWater_mm, 2) + tmin_C_avg+ tmax_C_avg
  } else {
    formula_kcal <- yield_kcalHa_detrended ~ poly(totalWater_mm, 2) + tmin_C_avg   + tmax_C_avg
    formula_kg   <- yield_kgHa_detrended ~ poly(totalWater_mm, 2) + tmin_C_avg   + tmax_C_avg
  }
  
  # fit models
  fit_kcal <- lm(formula_kcal, data = df_crop)
  fit_kg   <- lm(formula_kg, data = df_crop)
  
  # add fitted values
  df_crop$yield_kcalHa_detrended_fit <- fitted(fit_kcal)
  df_crop$yield_kgHa_detrended_fit   <- fitted(fit_kg)
  
  # package results
  list(
    crop = crop,
    fit_kcal = fit_kcal,
    fit_kg   = fit_kg,
    R2 = c(
      kcalHa = summary(fit_kcal)$adj.r.squared,
      kgHa   = summary(fit_kg)$adj.r.squared
    ),
    data = df_crop   # <- keep augmented dataframe for plotting
  )
}




# Run for all crops
yield_models <- lapply(c("Corn","Soybeans","Sorghum","Wheat"), function(crop) {
  fit_yield_models(df_crop, crop)
})

# Combine all augmented dfs back together
df_combo_aug <- dplyr::bind_rows(lapply(yield_models, function(m) m$data))
  
  
# Make R2 summary table
df_fit <- do.call(rbind, lapply(yield_models, function(m) {
  data.frame(
    Crop = m$crop,
    fit_R2_kcalHa = m$R2["kcalHa"],
    fit_R2_kgHa   = m$R2["kgHa"]
  )
}))


```
 
```{r}
# --- Higher level Model Wrapper for integration using fit_yield_models() ---
run_crop_models <- function(df) {
  crops <- unique(df$Crop)
  
  results <- lapply(crops, function(crop) {
    fit_yield_models(df, crop)   # <- now passing crop explicitly
  })
  
  # Combine all augmented crop data
  df_combo_aug <- do.call(rbind, lapply(results, function(x) x$data))
  
  # Summarize fit stats
  df_fit <- data.frame(
    Crop = sapply(results, function(x) x$crop),
    fit_R2_kcalHa = sapply(results, function(x) x$R2["kcalHa"]),
    fit_R2_kgHa   = sapply(results, function(x) x$R2["kgHa"])
  )
  
  list(
    data = df_combo_aug,
    fit_stats = df_fit,
    models = results
  )
}

# Should now work without the "crop missing" error
crop_results <- run_crop_models(df_crop)

# Look at first few rows of augmented data
head(crop_results$data)

# Look at model R2s
crop_results$fit_stats
```
 
 
  
  - plots for ^ model
```{r}
ggplot(df_combo_aug, aes(x = totalWater_mm, y = yield_kcalHa_detrended)) +
  geom_point(aes(color = WaterManagement)) +
  facet_wrap(~ Crop, scales = "free_y") +
  labs(x = "Precipitation + Irrigation [mm]", 
       y = "Yield [kcal/ha]") + 
  scale_color_manual(
    name = "Water Management",
    values = c("blue" , "orange" ) ) + 
  # fit line is now consistent with wrapper model
  geom_line(aes(y = yield_kcalHa_detrended_fit), color = "grey", size = 1, alpha = 0.2) +
    stat_smooth(method = "lm", formula = y ~ poly(x, 2), color = "black") +
  theme(legend.position = "bottom")

# save figure
#ggsave(
 # file.path("figures", "Submodel_CropWater_WaterProductivityCurves.png"),
 # width = 120, height = 120, units = "mm")



# Join R² values from wrapper outputs
r2_df <- df_fit |>
  select(Crop, fit_R2_kcalHa) |>
  mutate(
    label = paste0("R² = ", round(fit_R2_kcalHa, 2))  )

# Predicted vs Observed plot with R² annotations
ggplot(df_combo_aug, aes(x = yield_kcalHa_detrended_fit, y = yield_kcalHa_detrended)) +
  geom_abline(intercept = 0, slope = 1, color = "gray") +
  geom_point(aes(color = WaterManagement)) +
  facet_wrap(~ Crop, scales = "free") +
  scale_color_manual(
    name = "Water Management",
    values = c("blue" , "orange" ) ) + 
  stat_smooth(method = "lm", color = "black") +
  labs(
    x = "Predicted Yield [kcal/ha]", 
    y = "Observed Yield [kcal/ha]",
    title = "Predicted vs Observed"
  ) +
  geom_text(
    data = r2_df, 
    aes(x = Inf, y = Inf, label = label), 
    inherit.aes = FALSE, 
    hjust = 4.1, vjust = 2, size = 3.5
  )


```
  
  - OG model (1990-2023) and this model (2006-2023) are in agreement
  
  2. SW quality model (simplified)
    - Additional data - N data
    - Need to use LandCoverGroup in model as variable (not LandCover)
    - Agg across counties to basin scale, calc climate vars
    - lm fx
```{r}
df_nitrate <- read_csv(file.path("data", "RiverNitrateData_EKSRB.csv"))

df_WQual_LU_long <- df_combined |> 
  group_by(Year, LandCoverGroup) |> 
  summarize(group_area_ha = sum(area_ha_mean))|> 
  pivot_wider(names_from = LandCoverGroup, names_prefix = "LandCover_ha_", 
              values_from = group_area_ha, values_fill = NA) |>
  left_join(df_nitrate, by = c("Year"))

df_WQual_climate <- df_combined |>
  group_by(Year) |> 
  summarize(Climate_precip_mm = sum(precip_mm),
            Climate_Tmin_C = mean(tmin_C_avg),
            Climate_Tmax_C = mean(tmax_C_avg) ) |> 
  mutate(Climate_Tmean_C = (Climate_Tmin_C + Climate_Tmax_C) / 2 ) |>
  left_join(df_WQual_LU_long, by = c("Year"))


df_WQual_LU_WaterUse <-  df_combined |> 
  group_by(Year, LandCoverGroup) |> 
  summarize(waterUse_mm = sum(irrigation_WaterUse_mm, na.rm = TRUE))|> 
  group_by(Year) |> 
  summarize(Management_irrigation_mm = sum(waterUse_mm, na.rm = TRUE)) |> 
  left_join(df_WQual_climate, by = c("Year"))

  
  
df_WQual_LU_Fert <- df_combined |> 
  group_by(Year, LandCoverGroup) |> 
  summarize(fertilizer_kgCult = sum(fertilizer_kgCrop, na.rm = TRUE))|> 
  group_by(Year) |> 
  group_by(Year) |> 
  summarize(Management_FertilizerUse_kg = sum(fertilizer_kgCult, na.rm = TRUE)) |> 
  left_join(df_WQual_LU_WaterUse, by = c("Year"))




#work this in!! ^^
ecdf_precip <- ecdf(df_WQual_LU_Fert$Climate_precip_mm)

# calculate annual percentile and percentile change
df_WQual_LU_Fert$precip_percentile <- ecdf_precip(df_WQual_LU_Fert$Climate_precip_mm)
ggplot(df_WQual_LU_Fert, aes(x = Climate_precip_mm, y = precip_percentile)) + geom_point()
df_WQual_LU_Fert$precip_percentileChange <- df_WQual_LU_Fert$precip_percentile - lag(df_WQual_LU_Fert$precip_percentile, 1)


           


# --- Water Quality Model Wrapper ---
run_waterquality_model <- function(df) {
  
  # Fit MLR model
  mlr_nitrate <- lm(
    NitrateFlux_kg ~ 
      LandCover_ha_developed + 
      LandCover_ha_grassPastureHay + 
      `LandCover_ha_all cult` + 
      Climate_precip_mm + 
      Climate_Tmean_C + 
    #  Climate_SPEI6_mean + 
     precip_percentileChange + 
     Management_irrigation_mm + 
      Management_FertilizerUse_kg,
    data = df
  )
  
  # Add predictions
  df$NitrateFluxPredicted_kg <- predict(mlr_nitrate, newdata = df)
  
  # Calculate evaluation metric(s)
  mae_val <- mae(df$NitrateFluxPredicted_kg, df$NitrateFlux_kg, na.rm = TRUE)
  nmae_val <- mae_val / (max(df$NitrateFluxPredicted_kg, na.rm = TRUE) - 
                         min(df$NitrateFluxPredicted_kg, na.rm = TRUE))
  
  # Return structured output
  list(
    data = df,
    model = mlr_nitrate,
    performance = list(MAE = mae_val, NMAE = nmae_val)
  )
}

```
  
  - Run lm and assess outputs
```{r}
# Run wrapper
df_WQual_all <- df_WQual_LU_Fert |> drop_na()
wq_results <- run_waterquality_model(df_WQual_all)

# Access outputs
df_wq_aug <- wq_results$data
summary(wq_results$model)
wq_results$performance


df_wq_aug %>%
  dplyr::select(Year, NitrateFlux_kg, NitrateFluxPredicted_kg, NitrateFluxShreyaPredicted_kg) %>%
  pivot_longer(-Year, names_to = "Variable", values_to = "NitrateFlux_kg") %>%
  mutate(Source = case_when(
    Variable == "NitrateFlux_kg" ~ "Observed",
    Variable == "NitrateFluxPredicted_kg" ~ "Optimization MLR",
    Variable == "NitrateFluxShreyaPredicted_kg" ~ "Shreya MLR"
  )) %>%
  ggplot(aes(x = Year, y = NitrateFlux_kg, color = Source)) +
  geom_point() +
  geom_line() +
  scale_color_manual(
    name = NULL, values = c("black", "red", "green")
  ) +
  labs(y = "Nitrate Flux [kg/yr]", title = "Water Quality Model Validation") +
  theme(
    legend.position = "inside", 
    legend.position.inside = c(0.05, 0.95),
    legend.justification = c(0, 1)
  ) +
  guides(color = guide_legend(nrow = 3))
```

 3. Farmer net return model (place holder for more general community resilience)
  - From Ikenna paper, NR (dollar/ha) = Yield (kg/ha) X Price (dollar/kg) - sum(cost_irr (dollar/ha) + other prod costs)
  - only have corn right now
 
```{r}
# --- Universal costs ---
universal_costs <- list(
  fert_cost_ha = 469.8,       # $/ha
  irr_cost_per_m3 = 0.029     # $/m3
)

# --- Crop-specific info ---
crop_params <- tibble::tribble(
  ~Crop,       ~price_per_kg, ~seed_cost_ha,
  "Corn",      0.18,          243
  #,"Soybeans", 0.40,          150   # <- add later
  #,"Wheat",    0.25,          120
  #,"Sorghum",  0.12,          100
)

# --- Join crop params + compute NR ---
df_combo_NR <- df_combo_aug %>%
  # join in crop-specific info
  left_join(crop_params, by = "Crop") %>%
  # compute NR
  mutate(
    fert_cost = universal_costs$fert_cost_ha,
    irr_cost  = irrigation_WaterUse_mm * universal_costs$irr_cost_per_m3,
    NetReturn_dollarHa = (yield_kgHa_detrended_fit * price_per_kg) -
                         (fert_cost + seed_cost_ha + irr_cost)
  )

#plot
df_combo_NR %>%
  group_by(Year, Crop) %>%
  summarise(mean_NR = mean(NetReturn_dollarHa, na.rm = TRUE), .groups = "drop") %>%
  ggplot(aes(x = Year, y = mean_NR, color = Crop)) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  labs(
    title = "Annual Net Returns by Crop",
    y = "Net Return ($/ha)",
    x = "Year"
  ) +
  theme_test(base_size = 14)
```
 
 
# Integration fx - can pull this into different R markdown if this one is getting too long
  - NR function in the int code rather than indep. like ^^ (once int is validated I will remove above code chunk!)

```{r}
# --- Define your cost/price parameters ---
universal_costs <- list(
  irr_cost_ha = 0.029,   # $/m3 - likely mismatched with the data (mm - working in getting irr_ha by crop by county)
  fert_cost_ha = 469.8   # $/ha (constant across crops)
)

crop_params <- list(
  Corn = list(
    profit_perkg = 0.18,  # $/kg
    seed_cost = 243       # $/ha
  )
  # Add other crops here as you get data
)


# --- Updated integrate_models function ---
integrate_models <- function(df_crop_input, df_wq_input,
                             crop_params, universal_costs) {
  
  # Run crop submodels
  crop_results <- run_crop_models(df_crop_input)
  
  # Run water quality submodel
  wq_results <- run_waterquality_model(df_wq_input)
  
  # Harmonize outputs to annual basin scale (crop side)
  crop_summary <- crop_results$data %>%
    group_by(Year, Crop) %>%
    summarise(
      Yield_kcalHa = mean(yield_kcalHa_detrended_fit, na.rm = TRUE),
      Yield_kgHa   = mean(yield_kgHa_detrended_fit, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    # Add net return calculation
    mutate(
      Net_Return = case_when(
        Crop == "Corn" ~ (Yield_kgHa * crop_params$Corn$profit_perkg) -
                         (universal_costs$fert_cost_ha + crop_params$Corn$seed_cost),
        TRUE ~ NA_real_   # placeholder for other crops
      )
    )
  
  # Harmonize outputs to annual basin scale (WQ side)
  wq_summary <- wq_results$data %>%
    group_by(Year) %>%
    summarise(
      NitrateFluxPred_kg = mean(NitrateFluxPredicted_kg, na.rm = TRUE),
      .groups = "drop"
    )
  
  # Merge summaries
  integrated_df <- left_join(crop_summary, wq_summary, by = "Year")
  
  # Return integrated results
  list(
    integrated_data = integrated_df,
    crop = crop_results,
    waterquality = wq_results
  )
}


# --- Run integration with NR included ---
integration_results <- integrate_models(df_crop, df_WQual_all, crop_params, universal_costs)

# See harmonized outputs
integration_results$integrated_data %>% head()


#plots from integrated data


```

  - checking integrated outputs
```{r}
df_int <- integration_results$integrated_data
df_long <- df_int %>%
  select(Year, Crop, Yield_kcalHa, Yield_kgHa, Net_Return, NitrateFluxPred_kg) %>%
  pivot_longer(cols = c(Yield_kcalHa, Yield_kgHa, Net_Return, NitrateFluxPred_kg),
               names_to = "Variable", values_to = "Value")

ggplot(df_long, aes(x = Year, y = Value, color = Crop)) +
  geom_line() +
  geom_point() +
  facet_wrap(~ Variable, scales = "free_y", ncol = 2) +
  labs(title = "Integrated Model Outputs Over Time",
       y = "Value", x = "Year")
```
  
  - initial pareto frontier plots
```{r}
ggplot(df_int, aes(x = NitrateFluxPred_kg, 
                   y = Net_Return, 
                   color = Yield_kcalHa,
                   shape = Crop)) +
  geom_point(size = 4) +
  scale_color_viridis_c(name = "Yield (kcal/ha)") +
  labs(title = "Pareto Frontier: Yield, Net Return, and Nitrate Flux",
       x = "Nitrate Flux (kg)",
       y = "Net Return ($/ha)") +
  theme_test()



#install.packages("rPref")
library("rPref")

# Calculate Skyline
sky1 <- psel(df_int, high(Yield_kgHa) * low(NitrateFluxPred_kg))
# Plot mpg and hp values of mtcars and highlight the skyline
ggplot(df_int, aes(x =NitrateFluxPred_kg , y = Yield_kgHa)) + geom_point(shape = 21) +   geom_point(data = sky1, size = 3)



p <- high(Yield_kgHa) * low(NitrateFluxPred_kg)
# Calculate the level-value w.r.t. p by using top-all
res <- psel(df_int, p, top = nrow(df_int))
# Visualize the level values by the color of the points
gp <- ggplot(res, aes(x =NitrateFluxPred_kg , y = Yield_kgHa, color = factor(.level))) +
  geom_point(size = 3)
gp

gp + geom_step(direction = "vh")

```


- next steps... 
    - need to get irr data (irr_ha by crop, county, year, not just irr amount (mm)) - talk with Sam
    - need to calc GDD from gridmet climate data (by crop, county, year)
